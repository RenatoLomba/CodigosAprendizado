ASP.NET MVC

Linha de Comando:
dotnet --version					--> Mostra versoes do .Net
dotnet new						--> Abre as possiblidades de projetos em C# .Net
dotnet new sln --name NovaSolucao			--> Cria uma solução em .Net
dotnet new console -n Programa -o programa		--> Cria um projeto do console em .Net, com a saída em programa
dotnet new webapi -n aplication -n API.Aplication	--> Cria uma Web API em .Net
dotnet new classlib -n Domain -o Api.Domain -f netcoreapp3.1	--> Cria uma library de Class Domain
dotnet sln add programa					--> Adiciona o projeto a uma solução
dotnet run						--> Roda o arquivo .csproj do .Net
dotnet restore						--> Restaura os pacotes .Net
dotnet build						--> Compila a solução .Net
dotnet clean						--> Limpa os pacotes .Net
dotnet tool install --global dotnet-ef			--> Instala a Ferramenta do EntityFramework
dotnet add .\API.Data\ reference .\API.Domain\		--> Adiciona uma referencia de Domain em Data, pois as camadas Infra e Domain se conversam
dotnet ef migrations add EntityMigration		--> Adiciona uma migração com o EntityFramework
dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection --version 8.1.0	--> Configura a Injeção de Dependencia AutoMapper na CrossCutting

Metodos HTTP:
GET	--> Recuperar dados
POST	--> Adicionar dados
PUT	--> Atualizar dados
DELETE	--> Deletar dados

Projeto:
Domain		--> Camada que conterá as Entidades da Aplicação
Entity		--> Representação em Classe de uma Tabela do Banco de Dados
Guid		--> Tipo que representa um identificador único global
DateTime.UtcNow	--> Retorna a hora atual configurada no servidor
public abstract class BaseEntity	--> Entidade base onde todas as Entidades herdarão seus atributos
public class UserEntity : BaseEntity	--> Entidade herdando as propriedades de BaseEntity
dotnet ef database update		--> Realiza as alterações com base na Migração criada
public interface IRepository<T> where T : BaseEntity	--> Cria um Repositório genérico que aceitara qualquer Entidade que herde de BaseEntity
[Required]		--> Campo da classe é obrigatório
[EmailAddress]		--> Campo deverá receber um email válido
[StringLength(100)]	--> Campo com no máximo 100 caracteres

Data		--> Camada responsável pelo EntityFrameworkCore
EntityFrameworkCoreSqlServer	--> Pacote EntityFramework para SQLServer
PomeloEntityFrameworkCoreMySQL	--> Pacote EntityFramework para MySQL
EntityFrameworkCoreTools	--> Pacote de Ferramentas do EntityFramework
EntityFrameworkCoreDesign	--> Pacote de Design do EntityFramework
Context : DbContext		--> Classe que irá relacionar as Entidades de Dominio com o EntityFramework
DbSet<Entity> Entidades		--> Propriedade que referencia a Entidade Entity
ContextFactory			--> Classe que realizará a migração com o banco em tempo de execução
EntityMap			--> Classe de mapeamento da Entidade Entity
Migration			--> Usada para definição e alteração de tabelas no banco

Service		--> Camada responsável pelas regras de negócio, e que fará a ligação da Application com a Infra (usuário com o banco)

Application			--> Camada com os controladores da aplicação, onde o usuário acessará diretamente através das requisições HTTP
Controller			--> Controlador da aplicação, onde são feitas todas as requisições Http
[Route("api/[controller]")]	--> Indica que aquele é um controller de API
[ApiController]
http://localhost:5000/api/users	--> Acessa a api no controlador users
[HttpGet]			--> Indica que o metodo é GET
BadRequest			--> Código 400 - Sintaxe Inválida
NotFound			--> Código 404 - Não Encontrado
Ok				--> Código 200 - Requisição bem-sucedida
Created				--> Código 201 - Objeto criado com sucesso
[Route("{id}", Name = "GetById")]		--> Configura o parâmetro do método e o Nome dele na Rota
http://localhost:5000/api/users/GetById/123abc	--> Acessa o metodo na api passando o id 123abc
[HttpDelete("{id}")]		--> Espera um parâmetro na rota do endereço


CrossCutting			--> Camada de Configuração das Injeções de Dependência de Serviços
StartUp				--> Classe onde terá a configuração das Injeções de Dependencias criadas na CrossCutting

Model		--> Responsável por manter os dados e lógica de negócio da aplicação (Back-end)
View		--> É a interface com o usuário da app que exibe os dados (Front-end)
Controller	--> Recebe e trata as requisições e renderiza a view apropriada com os dados (Front to Back/Back to Front)
http://localhost/Home/Index	--> Home é o Controlador da apliação, e Index é uma ação do controlador que retorna uma resposta
Entity Framework Core		--> Classes de Domínio são mapeadas pelo ORM e assim são geradas as tabelas do banco de acordo
microsoft.entityframeworkcore				--> Pacote do EFC
microsoft.entityframeworkcore.sqlserver			--> Pacote para conexão entre EFC e SQLServer
microsoft.entityframeworkcore.Tools			--> Pacote de Ferramentas do EFC
microsoft.visualstudio.web.codegeneration.design	--> Pacote para Web do VStudio
microsoft.aspnetcore.identity.entityframeworkcore	--> Pacote ASP NET Identidade
class Classe : DBContext		--> Classe que representa uma sessao a com o Banco em tempo de execução
DBSet<Classe> Tabela			--> Propriedade que mapeia uma tabela no banco com base em uma classe
Data Source=localhost;Initial Catalog=LanchesMacDataBase;Integrated Security=True	--> String de Conexão na DB
[StringLength(250)]			--> DataAnnotation para mapear um campo como NVARCHAR(250)
[Column(TypeName ="decimal(18,2)")] 	--> DataAnnotation para mapear o campo como DECIMAL de 2 casas
add-migration MigracaoInicial		--> No Console do NuGet, adiciona uma migração no projeto, criando a Tabela do DB
remove-migration			--> Remove a migração criada
update-database				--> Cria efetivamente o banco com as tabelas e campos criados
add-migration PopularTabelas		--> Cria uma migração para popular as tabelas
migrationsBuilder.Sql("COMANDO SQL")	--> Comando para comunicação com o SQL (INSERT, UPDATE, DELETE, SELECT...)
update-database				--> Executa os comandos SQL passados no migrationsBuilder do metodo Up
Repository				--> Design Pattern que visa adicionar uma camada na aplicação responsavel pela comunicaocao
com o banco de dados
IExemploRepository			--> Interface que conterá os metodos de acesso ao banco (INSERT, UPDATE, DELETE, SELECT)
ClasseRepository			--> Classe que implementará os metodos
IEnumerable<Tipo>			--> Objeto numeravel de um tipo
Include(c => c.Tabela)			--> Select com Join de outra tabela
Where(p => p.Atributo)			--> Filtro Where da consulta
FirstOrDefault(l => l.Atributo == valor)--> Retorna o primeiro objeto com a clausula passada ou default
ViewBag.Valor = 'Qualquer valor'	--> Informações guardadas no ViewBag do controller podem ser acessadas na View
ViewData['Chave'] = 'Valor'		--> Semelhante ao ViewBag, poderá ser utilizado na View
@model IEnumerable<ViewModel>		--> Indica o modelo de dados a ser exibido na View
@foreach (var item in Model)		--> Faço um foreach percorrendo os objetos do modelo passado
Model					--> Acessa o modelo da página
wwwroot					--> Diretório público da aplicação, podendo ser acessado de fora
preco.ToString("c")			--> Retorna um valor modificado como a moeda local
_ViewStart				--> Arquivo que define a página que contem o Layout principal do site
_Layout					--> Página do Layout principal do site
_ViewImports				--> Página que contém os imports de scripts que serão usados por todas as Views
ViewModel				--> Model que é utilizado apenas para Visualização dos Dados, não sendo recomendado
passar dados da ViewModel para o Banco de Dados, apenas pelo Model de domínio
@await Html.PartialAsync("_PartialView")		--> Renderiza uma Partial View, que é uma Semi View que pode ser usada por diversas Views
dentro da aplicação
@await Html.PartialAsync("_PartialView", modelo)	--> Renderiza uma Partial View que terá os dados do Model passado junto no Html Helper
porem os dados alterados na Partial View não são recuperados na View Pai
<partial name="_PartialLanchesResumo" for="@lanche" />	--> Novo meio de se renderizar uma Partial View no Asp Net Core 3.0
Session					--> Armazena dados de requisições do usuário durante a sessão atual através de cookies,
uma Session expira após 20 minutos ou quando o usuário fecha o navegador
Session.Clear()				--> Mata a Sessão atual do usuário
const string SessionKeyNome = "_Nome"	--> Define uma constante que vai criar uma chave para armazenar um valor da Session
HttpContext.Session.SetString(SessionKeyNome, "Renato")	--> Atribui um valor do usuário a chave constante criada
var nome = context.Session.GetString(SessionKeyNome)	--> Recupera um valor contido na chave da Session passada
Guid					--> Representa um identificador unico global
Guid.NewGuid().ToString()		--> Gera um novo Guid Único